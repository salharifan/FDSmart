import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fdsmart/features/orders/models/order_model.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

class OrderViewModel extends ChangeNotifier {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  List<OrderModel> _myOrders = [];
  bool _isLoading = false;
  String? _errorMessage;

  List<OrderModel> get myOrders => _myOrders;
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;

  final List<OrderItemModel> _cartItems = [];
  List<OrderItemModel> get cartItems => _cartItems;

  double get cartTotal =>
      _cartItems.fold(0, (sum, item) => sum + (item.price * item.quantity));

  void addToCart(OrderItemModel item) {
    // Check if item already exists, if so update quantity
    int index = _cartItems.indexWhere((i) => i.menuItemId == item.menuItemId);
    if (index != -1) {
      // Create new object with updated quantity
      var existing = _cartItems[index];
      _cartItems[index] = OrderItemModel(
        menuItemId: existing.menuItemId,
        name: existing.name,
        price: existing.price,
        quantity: existing.quantity + item.quantity,
      );
    } else {
      _cartItems.add(item);
    }
    notifyListeners();
  }

  void removeFromCart(int index) {
    _cartItems.removeAt(index);
    notifyListeners();
  }

  void clearCart() {
    _cartItems.clear();
    notifyListeners();
  }

  // Create Order from Cart
  Future<int?> checkout(String userId) async {
    if (_cartItems.isEmpty) return null;
    int? token = await _createOrder(userId, _cartItems);
    if (token != null) {
      clearCart();
    }
    return token;
  }

  // Stream for real-time order updates (User Specific)
  Stream<List<OrderModel>> getMyOrdersStream(String userId) {
    return _firestore
        .collection('orders')
        .where('userId', isEqualTo: userId)
        .snapshots()
        .map((snapshot) {
          return snapshot.docs.map((doc) {
            return OrderModel.fromMap(doc.data(), doc.id);
          }).toList();
        });
  }

  // Stream for ALL orders (Admin)
  Stream<List<OrderModel>> getAllActiveOrdersStream() {
    return _firestore
        .collection('orders')
        // .where('status', whereIn: ['preparing', 'ready']) // Optional filter
        .snapshots()
        .map((snapshot) {
          return snapshot.docs.map((doc) {
            return OrderModel.fromMap(doc.data(), doc.id);
          }).toList();
        });
  }

  // Update Order Status (Admin)
  Future<void> updateOrderStatus(String orderId, String newStatus) async {
    await _firestore.collection('orders').doc(orderId).update({
      'status': newStatus,
    });
  }

  // Create Order (Internal)
  Future<int?> _createOrder(String userId, List<OrderItemModel> items) async {
    _isLoading = true;
    notifyListeners();

    try {
      double total = items.fold(
        0,
        (sum, item) => sum + (item.price * item.quantity),
      );

      // Auto-generate token number
      int token =
          (DateTime.now().millisecondsSinceEpoch % 900) + 100; // 100-999

      final newOrder = OrderModel(
        id: '', // Generated by Firestore
        userId: userId,
        items: List.from(items),
        totalPrice: total,
        status: 'preparing',
        tokenNumber: token,
        createdAt: DateTime.now(),
      );

      await _firestore.collection('orders').add(newOrder.toMap());

      _isLoading = false;
      notifyListeners();
      return token;
    } catch (e) {
      _errorMessage = e.toString();
      _isLoading = false;
      notifyListeners();
      return null;
    }
  }
}
